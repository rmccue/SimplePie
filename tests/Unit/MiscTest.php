<?php
/**
 * SimplePie
 *
 * A PHP-Based RSS and Atom Feed Framework.
 * Takes the hard work out of managing a complete RSS/Atom solution.
 *
 * Please note: This file is automatically generated by a build script. The
 * full original source is always available from http://simplepie.org/
 *
 * Copyright (c) 2004-2016, Ryan Parman, Sam Sneddon, Ryan McCue, and contributors
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 * 	* Redistributions of source code must retain the above copyright notice, this list of
 * 	  conditions and the following disclaimer.
 *
 * 	* Redistributions in binary form must reproduce the above copyright notice, this list
 * 	  of conditions and the following disclaimer in the documentation and/or other materials
 * 	  provided with the distribution.
 *
 * 	* Neither the name of the SimplePie Team nor the names of its contributors may be used
 * 	  to endorse or promote products derived from this software without specific prior
 * 	  written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS
 * AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * @package SimplePie
 * @copyright 2004-2016 Ryan Parman, Sam Sneddon, Ryan McCue
 * @author Ryan Parman
 * @author Sam Sneddon
 * @author Ryan McCue
 * @link http://simplepie.org/ SimplePie
 * @license http://www.opensource.org/licenses/bsd-license.php BSD License
 */

namespace SimplePie\Tests\Unit;

use PHPUnit\Framework\TestCase;
use SimplePie\Misc;
use SimplePie\Tests\Fixtures\MiscWithPublicStaticMethodsMock;

class MiscTest extends TestCase
{
	public function testNamespacedClassExists()
	{
		$this->assertTrue(class_exists('SimplePie\Misc'));
	}

	public function testClassExists()
	{
		$this->assertTrue(class_exists('SimplePie_Misc'));
	}

	/**
	 * #@+
	 * UTF-8 methods
	 *
	 * Provider for the convert toUTF8* tests
	 */
	public function utf8DataProvider()
	{
		return array(
			array('A', 'A', 'ASCII'),
			array("\xa1\xdb", "\xe2\x88\x9e", 'Big5'),
			array("\xa1\xe7", "\xe2\x88\x9e", 'EUC-JP'),
			array("\xa1\xde", "\xe2\x88\x9e", 'GBK'),
			array("\x81\x87", "\xe2\x88\x9e", 'Shift_JIS'),
			array("\x2b\x49\x68\x34\x2d", "\xe2\x88\x9e", 'UTF-7'),
			array("\xfe\xff\x22\x1e", "\xe2\x88\x9e", 'UTF-16'),
			array("\xff\xfe\x1e\x22", "\xe2\x88\x9e", 'UTF-16'),
			array("\x22\x1e", "\xe2\x88\x9e", 'UTF-16BE'),
			array("\x1e\x22", "\xe2\x88\x9e", 'UTF-16LE'),
		);
	}

	/**
	 * Convert * to UTF-8
	 *
	 * @dataProvider utf8DataProvider
	 */
	public function test_convert_UTF8($input, $expected, $encoding)
	{
		$encoding = Misc::encoding($encoding);
		$this->assertSameBin2Hex($expected, Misc::change_encoding($input, $encoding, 'UTF-8'));
	}

	/**
	 * Special cases with mbstring handling
	 */
	public function utf8MbstringDataProvider()
	{
		return array(
			array("\xa1\xc4", "\xe2\x88\x9e", 'EUC-KR'),
		);
	}

	/**
	 * Convert * to UTF-8 using mbstring
	 *
	 * Special cases only
	 * @dataProvider utf8MbstringDataProvider
	 */
	public function test_convert_UTF8_mbstring($input, $expected, $encoding)
	{
		if (! extension_loaded('mbstring')) {
			$this->markTestSkipped('Skipping test because mbstring extension is not available.');
		}

		$encoding = Misc::encoding($encoding);
		$this->assertSameBin2Hex($expected, MiscWithPublicStaticMethodsMock::change_encoding_mbstring($input, $encoding, 'UTF-8'));
	}

	/**
	 * Special cases with iconv handling
	 */
	public function utf8IconvDataProvider()
	{
		return array(
			array("\xfe\xff\x22\x1e", "\xe2\x88\x9e", 'UTF-16'),
		);
	}

	/**
	 * Convert * to UTF-8 using iconv
	 *
	 * Special cases only
	 * @dataProvider utf8IconvDataProvider
	 */
	public function test_convert_UTF8_iconv($input, $expected, $encoding)
	{
		if (! extension_loaded('iconv')) {
			$this->markTestSkipped('Skipping test because iconv extension is not available.');
		}

		$encoding = Misc::encoding($encoding);
		$this->assertSameBin2Hex($expected, MiscWithPublicStaticMethodsMock::change_encoding_iconv($input, $encoding, 'UTF-8'));
	}

	/**
	 * Special cases with uconverter handling
	 */
	public function utf8IntlDataProvider()
	{
		return array(
			array("\xfe\xff\x22\x1e", "\xe2\x88\x9e", 'UTF-16'),
		);
	}

	/**
	 * Convert * to UTF-8 using UConverter
	 *
	 * Special cases only
	 * @dataProvider utf8IntlDataProvider
	 */
	public function test_convert_UTF8_uconverter($input, $expected, $encoding)
	{
		if (! extension_loaded('intl')) {
			$this->markTestSkipped('Skipping test because intl extension is not available.');
		}

		$encoding = Misc::encoding($encoding);
		$this->assertSameBin2Hex($expected, MiscWithPublicStaticMethodsMock::change_encoding_uconverter($input, $encoding, 'UTF-8'));
	}
	/**#@-*/

	/**#@+
	 * UTF-16 methods
	 */
	public function utf16DataProvider()
	{
		return array(
			array("\x22\x1e", "\x22\x1e", 'UTF-16BE'),
			array("\x1e\x22", "\x22\x1e", 'UTF-16LE'),
		);
	}

	/**
	 * Convert * to UTF-16
	 * @dataProvider utf16DataProvider
	 */
	public function test_convert_UTF16($input, $expected, $encoding)
	{
		$encoding = Misc::encoding($encoding);
		$this->assertSameBin2Hex($expected, Misc::change_encoding($input, $encoding, 'UTF-16'));
	}
	/**#@-*/

	public function test_nonexistant()
	{
		$this->assertFalse(Misc::change_encoding('', 'TESTENC', 'UTF-8'));
	}

	public function assertSameBin2Hex($expected, $actual, $message = '')
	{
		if (is_string($expected))
		{
			$expected = bin2hex($expected);
		}
		if (is_string($actual))
		{
			$actual = bin2hex($actual);
		}
		$this->assertSame($expected, $actual, $message);
	}

	public function absolutizeUrlRFC3986DataProvider()
	{
		// The tests enclosed within come from RFC 3986 section 5.4
		// and all share the same base URL
		return [
			// normal
			[
				'g:h',
				'g:h',
			],
			[
				'g',
				'http://a/b/c/g',
			],
			[
				'./g',
				'http://a/b/c/g',
			],
			[
				'g/',
				'http://a/b/c/g/',
			],
			[
				'/g',
				'http://a/g',
			],
			[
				'//g',
				'http://g/',
			],
			[
				'?y',
				'http://a/b/c/d;p?y',
			],
			[
				'g?y',
				'http://a/b/c/g?y',
			],
			[
				'#s',
				'http://a/b/c/d;p?q#s',
			],
			[
				'g#s',
				'http://a/b/c/g#s',
			],
			[
				'g?y#s',
				'http://a/b/c/g?y#s',
			],
			[
				';x',
				'http://a/b/c/;x',
			],
			[
				'g;x',
				'http://a/b/c/g;x',
			],
			[
				'g;x?y#s',
				'http://a/b/c/g;x?y#s',
			],
			[
				'',
				'http://a/b/c/d;p?q',
			],
			[
				'.',
				'http://a/b/c/',
			],
			[
				'./',
				'http://a/b/c/',
			],
			[
				'..',
				'http://a/b/',
			],
			[
				'../',
				'http://a/b/',
			],
			[
				'../g',
				'http://a/b/g',
			],
			[
				'../..',
				'http://a/',
			],
			[
				'../../',
				'http://a/',
			],
			[
				'../../g',
				'http://a/g',
			],
			// abnormal
			[
				'../../../g',
				'http://a/g',
			],
			[
				'../../../../g',
				'http://a/g',
			],
			[
				'/./g',
				'http://a/g',
			],
			[
				'/../g',
				'http://a/g',
			],
			[
				'g.',
				'http://a/b/c/g.',
			],
			[
				'.g',
				'http://a/b/c/.g',
			],
			[
				'g..',
				'http://a/b/c/g..',
			],
			[
				'..g',
				'http://a/b/c/..g',
			],
			[
				'./../g',
				'http://a/b/g',
			],
			[
				'./g/.',
				'http://a/b/c/g/',
			],
			[
				'g/./h',
				'http://a/b/c/g/h',
			],
			[
				'g/../h',
				'http://a/b/c/h',
			],
			[
				'g;x=1/./y',
				'http://a/b/c/g;x=1/y',
			],
			[
				'g;x=1/../y',
				'http://a/b/c/y',
			],
			[
				'g?y/./x',
				'http://a/b/c/g?y/./x',
			],
			[
				'g?y/../x',
				'http://a/b/c/g?y/../x',
			],
			[
				'g#s/./x',
				'http://a/b/c/g#s/./x',
			],
			[
				'g#s/../x',
				'http://a/b/c/g#s/../x',
			],
			[
				'http:g',
				'http:g',
			],
		];
	}

	/**
	 * @dataProvider absolutizeUrlRFC3986DataProvider
	 */
	public function test_absolutize_url_RFC3986($relative, $expected)
	{
		$base = 'http://a/b/c/d;p?q';

		$this->assertSame(
			$expected,
			Misc::absolutize_url($relative, $base)
		);
	}
}
